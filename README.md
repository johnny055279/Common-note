# 目錄(for c#)
- <a href="#GC">GC運作原理</a>

## <a name="GC">GC運作原理</a>
### Stack & Heap
在.NET執行程式的時候，CLR針對不同的型別在記體體中會分配不同的空間進行儲存。

對於是`Value Type`而言，在宣告一個變數的時候，CLR會在Stack分配一個空間儲存，而在賦予值的時候也會在同樣的空間儲存。其特性是後進先出(LIFO)，而且一旦function執行完畢，就會被自動回收，不需要擔心memory leak的發生。

對於`Reference Type`而言，CLR會在Stack創造一塊儲存記憶體位址的空間，並且在初始化的時候在Heap上配置該型別所需要的空間，並且將記憶體位置回傳給Stack儲存。

由CLR自動配置與管理的記憶體，被稱為Managed resource；而不受CLR管理被稱為Unmanaged resource。

> *最常見的 Unmanaged 資源類型就是包裝作業系統資源 (例如檔案控制代碼、視窗控制代碼或網路連接) 的物件。*

基本上如果該變數或參考**不再有效**的時候，CLR會判定其為垃圾資源，並等待回收。

對於`Value Type`，CLR會直接回收Stack的空間;`Reference Type`而言，CLR一樣會回後Stack上面儲存的記憶體位置，此時Heap上面的空間就會被標記為垃圾。若重新被初始化，因為記憶體位置不同，原本的也同樣被標記為垃圾。

GC的機制並不是即時的，回收的條件可能有下列的原因:

- 系統的實體記憶體不足。 這是由 OS 的低記憶體通知或主機所指示的記憶體不足通知所偵測到。
- Managed 堆積上設定物件所使用的記憶體超過可接受的臨界值。 這個臨界值會在處理序執行時持續調整。
- 已呼叫 GC.Collect 方法。

GC的演算法有幾個考慮：
- 壓縮部分受控堆積的記憶體比整個受控堆積更快。
- 較新物件的存留期較短，而較舊的物件則存留期較長。
- 較新的物件通常會彼此相關，並由應用程式在相同時間存取。

在Heap上面的物件會被CLR區分三個等級：0、1、2來代表存活的時間長度。

大部分的物件都會在層代0回收，以進行垃圾收集，而不會存活到下一代。

如果今天層代0已經滿了但又必須創建新的物件，則CLR會把層代0還在使用的物件提升至層代1。如果又滿了就會把層代1的物件提升至層代2，最高就是2。

而進行回收的時候，會一並把等級低的一起回收，例如執行層代2回收時，會把1與0的也一起回收。

為了讓使用者可以明確的選擇Unmanaged resource回收的時機點，C#提供了一個Dispose()方法，使用者可以藉由繼承IDispose來使用。

當物件呼叫Dispose()的時候，有可能還是會被GC的自動回收機制Finalize()，因為這是避免Dispose()失敗後資源還是在那邊。

但是如果確定Dispose()成功執行，那會建議在後面再加一個`GC.SuppressFinalize(this);`，告訴GC不需要再去呼叫這個物件的Finalize()

